#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
COMPOSE_DIR="$ROOT_DIR/infra/compose"
COMPOSE_ENV_FILE="$COMPOSE_DIR/.env"
RUNNER_DIR="$ROOT_DIR/apps/host-runner"
RUNTIME_DIR="$ROOT_DIR/.multyagents-runtime"
RUNNER_PID_FILE="$RUNTIME_DIR/host-runner.pid"
RUNNER_LOG_FILE="$RUNTIME_DIR/host-runner.log"

mkdir -p "$RUNTIME_DIR"

command_exists() {
  command -v "$1" >/dev/null 2>&1
}

require_command() {
  local cmd="$1"
  if ! command_exists "$cmd"; then
    echo "missing required command: $cmd" >&2
    exit 1
  fi
}

load_compose_env() {
  if [[ -f "$COMPOSE_ENV_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$COMPOSE_ENV_FILE"
  fi
}

runner_port_from_url() {
  local url="$1"
  local no_proto="${url#*://}"
  local host_port="${no_proto%%/*}"
  echo "${host_port##*:}"
}

runner_port() {
  load_compose_env
  local runner_url="${API_HOST_RUNNER_URL:-http://host.docker.internal:48070}"
  runner_port_from_url "$runner_url"
}

api_port() {
  load_compose_env
  echo "${API_PORT:-48000}"
}

ui_port() {
  load_compose_env
  echo "${UI_PORT:-45173}"
}

telegram_port() {
  load_compose_env
  echo "${TELEGRAM_BOT_PORT:-48010}"
}

wait_http_ok() {
  local url="$1"
  local timeout="${2:-60}"
  local deadline=$((SECONDS + timeout))
  while (( SECONDS < deadline )); do
    if curl -fsS "$url" >/dev/null 2>&1; then
      return 0
    fi
    sleep 1
  done
  echo "timeout waiting for $url" >&2
  return 1
}

runner_pid() {
  if [[ -f "$RUNNER_PID_FILE" ]]; then
    cat "$RUNNER_PID_FILE"
  fi
}

runner_is_running() {
  local pid
  pid="$(runner_pid || true)"
  if [[ -z "${pid:-}" ]]; then
    return 1
  fi
  kill -0 "$pid" >/dev/null 2>&1
}

ensure_runner_venv() {
  if [[ ! -x "$RUNNER_DIR/.venv/bin/python" ]]; then
    python3 -m venv "$RUNNER_DIR/.venv"
    "$RUNNER_DIR/.venv/bin/pip" install -e "$RUNNER_DIR"
  fi
}

start_runner() {
  if runner_is_running; then
    echo "host-runner already running (pid=$(runner_pid))"
    return 0
  fi

  ensure_runner_venv

  local mode="${HOST_RUNNER_EXECUTOR:-codex}"
  if [[ "$mode" == "codex" ]]; then
    local codex_bin="${HOST_RUNNER_CODEX_BIN:-codex}"
    if ! command_exists "$codex_bin"; then
      echo "HOST_RUNNER_EXECUTOR=codex but binary not found: $codex_bin" >&2
      echo "set HOST_RUNNER_EXECUTOR=mock for local smoke mode" >&2
      exit 1
    fi
  fi

  local port
  port="$(runner_port)"
  echo "starting host-runner on 0.0.0.0:${port} (mode=${mode})"
  (
    cd "$RUNNER_DIR"
    export HOST_RUNNER_EXECUTOR="${mode}"
    export HOST_RUNNER_CODEX_BIN="${HOST_RUNNER_CODEX_BIN:-codex}"
    export HOST_RUNNER_CODEX_ARGS="${HOST_RUNNER_CODEX_ARGS:-}"
    export HOST_RUNNER_CLEANUP_WORKTREE="${HOST_RUNNER_CLEANUP_WORKTREE:-true}"
    nohup "$RUNNER_DIR/.venv/bin/uvicorn" \
      multyagents_host_runner.main:app \
      --host 0.0.0.0 \
      --port "$port" \
      >>"$RUNNER_LOG_FILE" 2>&1 < /dev/null &
    echo "$!" >"$RUNNER_PID_FILE"
  )

  if ! wait_http_ok "http://127.0.0.1:${port}/health" 45; then
    echo "host-runner failed to start, check log: $RUNNER_LOG_FILE" >&2
    stop_runner || true
    exit 1
  fi
}

stop_runner() {
  local pid
  pid="$(runner_pid || true)"
  if [[ -z "${pid:-}" ]]; then
    return 0
  fi
  if kill -0 "$pid" >/dev/null 2>&1; then
    echo "stopping host-runner (pid=$pid)"
    kill "$pid" >/dev/null 2>&1 || true
    wait "$pid" 2>/dev/null || true
  fi
  rm -f "$RUNNER_PID_FILE"
}

compose_up() {
  echo "starting docker compose stack"
  (cd "$COMPOSE_DIR" && docker compose up --build -d)
}

compose_down() {
  echo "stopping docker compose stack"
  (cd "$COMPOSE_DIR" && docker compose down --remove-orphans)
}

cmd_up() {
  require_command docker
  require_command python3
  require_command curl
  start_runner
  compose_up

  local a_port u_port t_port
  a_port="$(api_port)"
  u_port="$(ui_port)"
  t_port="$(telegram_port)"

  wait_http_ok "http://localhost:${a_port}/health" 90
  wait_http_ok "http://localhost:${t_port}/health" 90

  echo
  echo "stack is up:"
  echo "  api:       http://localhost:${a_port}"
  echo "  ui:        http://localhost:${u_port}"
  echo "  telegram:  http://localhost:${t_port}"
  echo "  runner:    http://localhost:$(runner_port)"
  echo
  echo "use './scripts/multyagents status' for health and process state"
}

cmd_down() {
  require_command docker
  compose_down
  stop_runner
  echo "stack is down"
}

cmd_status() {
  require_command docker
  local r_port a_port u_port t_port
  r_port="$(runner_port)"
  a_port="$(api_port)"
  u_port="$(ui_port)"
  t_port="$(telegram_port)"

  if runner_is_running; then
    echo "host-runner: running (pid=$(runner_pid))"
  else
    echo "host-runner: stopped"
  fi
  echo "host-runner log: $RUNNER_LOG_FILE"
  echo
  (cd "$COMPOSE_DIR" && docker compose ps)
  echo
  if curl -fsS "http://127.0.0.1:${r_port}/health" >/dev/null 2>&1; then
    echo "runner health: ok (http://127.0.0.1:${r_port}/health)"
  else
    echo "runner health: down (http://127.0.0.1:${r_port}/health)"
  fi
  if curl -fsS "http://localhost:${a_port}/health" >/dev/null 2>&1; then
    echo "api health: ok (http://localhost:${a_port}/health)"
  else
    echo "api health: down (http://localhost:${a_port}/health)"
  fi
  if curl -fsS "http://localhost:${t_port}/health" >/dev/null 2>&1; then
    echo "telegram health: ok (http://localhost:${t_port}/health)"
  else
    echo "telegram health: down (http://localhost:${t_port}/health)"
  fi
  echo "ui url: http://localhost:${u_port}"
}

cmd_logs() {
  require_command docker
  echo "==== host-runner log (tail 120) ===="
  if [[ -f "$RUNNER_LOG_FILE" ]]; then
    tail -n 120 "$RUNNER_LOG_FILE"
  else
    echo "no host-runner log yet"
  fi
  echo
  echo "==== docker compose logs (tail 120) ===="
  (cd "$COMPOSE_DIR" && docker compose logs --tail=120)
}

cmd_init_project() {
  require_command python3
  require_command curl

  local name="${1:-}"
  local root_path="${2:-}"
  if [[ -z "$name" || -z "$root_path" ]]; then
    echo "usage: ./scripts/multyagents init-project <name> <absolute_path>" >&2
    return 2
  fi

  case "$root_path" in
    /*) ;;
    *)
      echo "root_path must be absolute: $root_path" >&2
      return 2
      ;;
  esac

  mkdir -p "$root_path/src" "$root_path/docs" "$root_path/content"
  if [[ ! -f "$root_path/README.md" ]]; then
    cat > "$root_path/README.md" <<EOF
# $name

Created via ./scripts/multyagents init-project
EOF
  fi

  local api_base="http://127.0.0.1:$(api_port)"
  local payload
  payload="$(python3 - <<PY
import json
name = ${name@Q}
root = ${root_path@Q}
print(json.dumps({
  "name": name,
  "root_path": root,
  "allowed_paths": [f"{root}/src", f"{root}/docs", f"{root}/content"],
}))
PY
)"

  local response
  response="$(curl -fsS -X POST "$api_base/projects" -H 'content-type: application/json' -d "$payload")"
  python3 - "$response" <<'PY'
import json,sys
obj=json.loads(sys.argv[1])
print(f"project created: id={obj.get('id')} name={obj.get('name')} root={obj.get('root_path')}")
PY
}

cmd_e2e() {
  require_command docker
  require_command python3
  require_command curl
  (cd "$COMPOSE_DIR" && ./scripts/run-e2e.sh)
}

cmd_stress_smoke() {
  require_command docker
  require_command python3
  require_command curl
  (cd "$COMPOSE_DIR" && E2E_SCENARIO_SCRIPT=parallel_workflow_stress_smoke.py ./scripts/run-e2e.sh)
}

cmd_race_stress() {
  require_command python3
  (cd "$ROOT_DIR" && ./scripts/task-072-race-stress.sh)
}

cmd_chaos() {
  require_command python3
  require_command docker
  (cd "$ROOT_DIR" && ./scripts/task-071-chaos.sh)
}

cmd_readiness() {
  require_command python3
  (cd "$ROOT_DIR" && ./scripts/task-061-readiness.sh)
}

cmd_restart_persistence() {
  require_command python3
  (cd "$ROOT_DIR" && ./scripts/task-073-restart-persistence.sh)
}

cmd_slo_smoke() {
  require_command python3
  (cd "$ROOT_DIR" && ./scripts/task-076-slo-smoke.sh)
}

gate_v2_run_stage() {
  local idx="$1"
  local total="$2"
  local stage_id="$3"
  local label="$4"
  local cmd="$5"
  local summary_file="$6"
  local started="$SECONDS"
  local status="FAIL"

  echo "[gate-v2] ${idx}/${total} ${label}"
  if ( eval "$cmd" ); then
    status="PASS"
  fi

  local duration="$((SECONDS - started))"
  printf '[gate-v2] %s -> %s (%ss)\n' "$stage_id" "$status" "$duration"
  printf '%s|%s|%s|%s|%s\n' "$stage_id" "$label" "$status" "$duration" "$cmd" >>"$summary_file"

  [[ "$status" == "PASS" ]]
}

gate_v2_write_evidence() {
  local summary_file="$1"
  local evidence_dir="$2"
  local timestamp="$3"
  local json_evidence="$evidence_dir/task-077-gate-v2-$timestamp.json"
  local md_evidence="$evidence_dir/task-077-gate-v2-$timestamp.md"

  python3 - "$summary_file" "$json_evidence" "$md_evidence" <<'PY'
from __future__ import annotations

import json
from datetime import datetime, timezone
from pathlib import Path
import sys

summary_path = Path(sys.argv[1])
json_path = Path(sys.argv[2])
md_path = Path(sys.argv[3])

stages: list[dict[str, object]] = []
for raw_line in summary_path.read_text(encoding="utf-8").splitlines():
    line = raw_line.strip()
    if not line:
        continue
    stage_id, label, status, duration_seconds, command = line.split("|", 4)
    stages.append(
        {
            "stage_id": stage_id,
            "label": label,
            "status": status,
            "duration_seconds": int(duration_seconds),
            "command": command,
        }
    )

failed = sum(1 for stage in stages if stage["status"] != "PASS")
passed = len(stages) - failed
overall_status = "pass" if failed == 0 else "fail"

payload = {
    "task_id": "TASK-077",
    "generated_at": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
    "summary": {
        "total": len(stages),
        "passed": passed,
        "failed": failed,
        "overall_status": overall_status,
    },
    "stages": stages,
}

json_path.write_text(json.dumps(payload, indent=2) + "\n", encoding="utf-8")

md_lines = [
    "# TASK-077 gate-v2 evidence",
    "",
    f"- Generated at: `{payload['generated_at']}`",
    f"- Overall: `{overall_status}`",
    f"- Passed/Total: `{passed}/{len(stages)}`",
    "",
    "| Stage | Label | Status | Duration (s) |",
    "|---|---|---|---:|",
]
for stage in stages:
    md_lines.append(
        f"| `{stage['stage_id']}` | {stage['label']} | `{stage['status']}` | {stage['duration_seconds']} |"
    )

md_path.write_text("\n".join(md_lines) + "\n", encoding="utf-8")
PY

  cp "$json_evidence" "$evidence_dir/latest.json"
  cp "$md_evidence" "$evidence_dir/latest.md"

  echo "[gate-v2] evidence artifacts:"
  echo "  - $json_evidence"
  echo "  - $md_evidence"
}

gate_v2_print_summary() {
  local summary_file="$1"
  local total="$2"
  local passed=0
  local failed=0
  local stage_id=""
  local label=""
  local status=""
  local duration=""
  local cmd=""

  echo
  echo "[gate-v2] Stage summary"
  printf '  %-4s %-34s %-6s %s\n' "ID" "Stage" "Result" "Duration"
  while IFS='|' read -r stage_id label status duration cmd; do
    [[ -z "${stage_id:-}" ]] && continue
    if [[ "$status" == "PASS" ]]; then
      passed=$((passed + 1))
    else
      failed=$((failed + 1))
    fi
    printf '  %-4s %-34s %-6s %ss\n' "$stage_id" "$label" "$status" "$duration"
  done <"$summary_file"

  echo
  if [[ "$failed" -eq 0 ]]; then
    echo "[gate-v2] FINAL VERDICT: PASS (${passed}/${total} stages passed)"
    return 0
  fi
  echo "[gate-v2] FINAL VERDICT: FAIL (${failed}/${total} stages failed)" >&2
  return 1
}

cmd_gate() {
  require_command python3
  require_command docker
  local failed=0

  echo "[gate] 1/6 API regression"
  (cd "$ROOT_DIR/apps/api" && .venv/bin/pytest -q) || failed=1

  echo "[gate] 2/6 Telegram bot regression"
  (cd "$ROOT_DIR/apps/telegram-bot" && .venv/bin/pytest -q) || failed=1

  echo "[gate] 3/6 UI production build"
  (cd "$ROOT_DIR/apps/ui" && npm run build) || failed=1

  echo "[gate] 4/6 UI smoke tests"
  (cd "$ROOT_DIR" && ./scripts/ui-test-smoke.sh) || failed=1

  echo "[gate] 5/6 Local readiness scenarios"
  (cd "$ROOT_DIR" && ./scripts/multyagents readiness) || failed=1

  echo "[gate] 6/6 Compose E2E smoke"
  (cd "$ROOT_DIR" && ./scripts/multyagents e2e) || failed=1

  echo
  if [[ "$failed" -eq 0 ]]; then
    echo "[gate] ✅ PASS: all reliability checks passed"
    return 0
  fi
  echo "[gate] ❌ FAIL: one or more reliability checks failed" >&2
  return 1
}

cmd_gate_v2() {
  require_command python3
  local failed=0
  local total=10
  local summary_file=""
  local evidence_dir="${TASK_077_EVIDENCE_DIR:-$ROOT_DIR/docs/evidence/task-077}"
  local timestamp
  timestamp="$(date -u +%Y%m%dT%H%M%SZ)"

  mkdir -p "$evidence_dir"
  summary_file="$(mktemp)"
  trap "rm -f '$summary_file'" RETURN

  gate_v2_run_stage 1 "$total" "S01" "API regression" \
    "cd \"$ROOT_DIR/apps/api\" && .venv/bin/pytest -q" \
    "$summary_file" || failed=1

  gate_v2_run_stage 2 "$total" "S02" "Telegram bot regression" \
    "cd \"$ROOT_DIR/apps/telegram-bot\" && .venv/bin/pytest -q" \
    "$summary_file" || failed=1

  gate_v2_run_stage 3 "$total" "S03" "UI build" \
    "cd \"$ROOT_DIR/apps/ui\" && npm run build" \
    "$summary_file" || failed=1

  gate_v2_run_stage 4 "$total" "S04" "UI smoke" \
    "cd \"$ROOT_DIR\" && ./scripts/ui-test-smoke.sh" \
    "$summary_file" || failed=1

  gate_v2_run_stage 5 "$total" "S05" "Local readiness" \
    "cd \"$ROOT_DIR\" && ./scripts/task-061-readiness.sh" \
    "$summary_file" || failed=1

  gate_v2_run_stage 6 "$total" "S06" "Compose E2E smoke" \
    "cd \"$ROOT_DIR/infra/compose\" && ./scripts/run-e2e.sh" \
    "$summary_file" || failed=1

  gate_v2_run_stage 7 "$total" "S07" "Chaos failure drills" \
    "cd \"$ROOT_DIR/infra/compose\" && E2E_SCENARIO_SCRIPT=chaos_e2e_failure_drills.py ./scripts/run-e2e.sh" \
    "$summary_file" || failed=1

  gate_v2_run_stage 8 "$total" "S08" "Race stress suite" \
    "cd \"$ROOT_DIR\" && ./scripts/task-072-race-stress.sh" \
    "$summary_file" || failed=1

  gate_v2_run_stage 9 "$total" "S09" "Restart persistence suite" \
    "cd \"$ROOT_DIR\" && ./scripts/task-073-restart-persistence.sh" \
    "$summary_file" || failed=1

  gate_v2_run_stage 10 "$total" "S10" "Security adversarial suite" \
    "cd \"$ROOT_DIR/apps/api\" && .venv/bin/pytest -q tests/test_api_security_adversarial.py" \
    "$summary_file" || failed=1

  gate_v2_write_evidence "$summary_file" "$evidence_dir" "$timestamp"
  gate_v2_print_summary "$summary_file" "$total" || failed=1

  if [[ "$failed" -eq 0 ]]; then
    return 0
  fi
  return 1
}

cmd_desktop() {
  require_command node
  require_command npm
  local desktop_dir="$ROOT_DIR/apps/desktop"
  local npm_script="start"
  if [[ ! -f "$desktop_dir/package.json" ]]; then
    echo "desktop app not found: $desktop_dir/package.json" >&2
    exit 1
  fi
  if [[ ! -x "$desktop_dir/node_modules/.bin/electron" ]]; then
    echo "installing desktop dependencies"
    (cd "$desktop_dir" && npm install --no-audit --no-fund)
  fi
  if [[ "$(uname -s)" == "Linux" ]]; then
    local sandbox_bin="$desktop_dir/node_modules/electron/dist/chrome-sandbox"
    local sandbox_uid=""
    local sandbox_mode=""
    if [[ -f "$sandbox_bin" ]]; then
      sandbox_uid="$(stat -c '%u' "$sandbox_bin" 2>/dev/null || true)"
      sandbox_mode="$(stat -c '%a' "$sandbox_bin" 2>/dev/null || true)"
    fi
    if [[ "${sandbox_uid:-}" != "0" || "${sandbox_mode:-}" != "4755" ]]; then
      npm_script="start:no-sandbox"
      echo "warning: running Electron with --no-sandbox (chrome-sandbox is not root:4755)" >&2
      echo "to enable sandbox: sudo chown root:root \"$sandbox_bin\" && sudo chmod 4755 \"$sandbox_bin\"" >&2
    fi
  fi
  (cd "$desktop_dir" && npm run "$npm_script")
}

cmd_help() {
  cat <<'EOF'
Usage: ./scripts/multyagents <command>

Commands:
  up       Start host-runner + docker stack and wait for health
  down     Stop docker stack and host-runner
  status   Show process/container status and health checks
  logs     Show recent host-runner and docker logs
  init-project Create physical project dir + register project in API
  e2e      Run end-to-end smoke scenario
  stress-smoke Run parallel workflow stress smoke scenario
  race-stress Run TASK-072 concurrency/race stress suite (alias: stress-race)
  chaos    Run TASK-071 chaos failure drills scenario
  readiness Run TASK-061 local readiness scenarios and evidence capture
  restart-persistence Run TASK-073 restart persistence invariant suite (alias: persistence-restart)
  slo-smoke Run TASK-076 SLO load/soak benchmark suite (alias: task-076)
  gate     Run full reliability gate (api+bot+ui+smoke+readiness+e2e)
  gate-v2  Run release gate v2 with hard-fail stages and TASK-077 evidence
  desktop  Launch Electron desktop control panel
  help     Show this help

Environment overrides:
  HOST_RUNNER_EXECUTOR   default: codex (use mock for local no-codex mode)
  HOST_RUNNER_CODEX_BIN  default: codex
  HOST_RUNNER_CODEX_ARGS default: empty
EOF
}

main() {
  local cmd="${1:-help}"
  case "$cmd" in
    up) cmd_up ;;
    down) cmd_down ;;
    status) cmd_status ;;
    logs) cmd_logs ;;
    init-project) shift; cmd_init_project "$@" ;;
    e2e) cmd_e2e ;;
    stress-smoke) cmd_stress_smoke ;;
    race-stress|stress-race) cmd_race_stress ;;
    chaos) cmd_chaos ;;
    readiness) cmd_readiness ;;
    restart-persistence|persistence-restart) cmd_restart_persistence ;;
    slo-smoke|task-076) cmd_slo_smoke ;;
    gate) cmd_gate ;;
    gate-v2) cmd_gate_v2 ;;
    desktop) cmd_desktop ;;
    help|-h|--help) cmd_help ;;
    *)
      echo "unknown command: $cmd" >&2
      cmd_help
      exit 1
      ;;
  esac
}

main "$@"
